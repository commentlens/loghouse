
// Package symbols is generated by gogll. Do not edit.
package symbols

import(
	"bytes"
	"fmt"
)

type Symbol interface{
	isSymbol()
	IsNonTerminal() bool
	String() string
}

func (NT) isSymbol() {}
func (T) isSymbol() {}

// NT is the type of non-terminals symbols
type NT int
const( 
	NT_LabelFilter NT = iota
	NT_LabelFilterOp 
	NT_LabelKey 
	NT_LineFilter 
	NT_LineFilterOp 
	NT_LogQuery 
	NT_LogSelector 
	NT_LogSelectorMember 
	NT_LogSelectorMembers 
	NT_LogSelectorMembersMaybe 
	NT_LogSelectorOp 
	NT_MetricQuery 
	NT_NestedLabelKey 
	NT_Pipeline 
	NT_Pipelines 
	NT_PipelinesMaybe 
	NT_Query 
)

// T is the type of terminals symbols
type T int
const( 
	T_0 T = iota // != 
	T_1  // !~ 
	T_2  // ( 
	T_3  // ) 
	T_4  // , 
	T_5  // . 
	T_6  // < 
	T_7  // <= 
	T_8  // = 
	T_9  // =~ 
	T_10  // > 
	T_11  // >= 
	T_12  // [ 
	T_13  // ] 
	T_14  // by 
	T_15  // count_over_time 
	T_16  // duration 
	T_17  // level 
	T_18  // string 
	T_19  // sum 
	T_20  // var_name 
	T_21  // { 
	T_22  // | 
	T_23  // |= 
	T_24  // |~ 
	T_25  // } 
)

type Symbols []Symbol

func (ss Symbols) Equal(ss1 Symbols) bool {
	if len(ss) != len(ss1) {
		return false
	}
	for i, s := range ss {
		if s.String() != ss1[i].String() {
			return false
		}
	}
	return true
}

func (ss Symbols) String() string {
	w := new(bytes.Buffer)
	for i, s := range ss {
		if i > 0 {
			fmt.Fprint(w, " ")
		}
		fmt.Fprintf(w, "%s", s)
	}
	return w.String()
}

func (ss Symbols) Strings() []string {
	strs := make([]string, len(ss))
	for i, s := range ss {
		strs[i] = s.String()
	}
	return strs
}

func (NT) IsNonTerminal() bool {
	return true
}

func (T) IsNonTerminal() bool {
	return false
}

func (nt NT) String() string {
	return ntToString[nt]
}

func (t T) String() string {
	return tToString[t]
}

// IsNT returns true iff sym is a non-terminal symbol of the grammar
func IsNT(sym string) bool {
	_, exist := stringNT[sym]
	return exist
}

// ToNT returns the NT value of sym or panics if sym is not a non-terminal of the grammar
func ToNT(sym string) NT {
	nt, exist := stringNT[sym]
	if !exist {
		panic(fmt.Sprintf("No NT: %s", sym))
	}
	return nt
}

var ntToString = []string { 
	"LabelFilter", /* NT_LabelFilter */
	"LabelFilterOp", /* NT_LabelFilterOp */
	"LabelKey", /* NT_LabelKey */
	"LineFilter", /* NT_LineFilter */
	"LineFilterOp", /* NT_LineFilterOp */
	"LogQuery", /* NT_LogQuery */
	"LogSelector", /* NT_LogSelector */
	"LogSelectorMember", /* NT_LogSelectorMember */
	"LogSelectorMembers", /* NT_LogSelectorMembers */
	"LogSelectorMembersMaybe", /* NT_LogSelectorMembersMaybe */
	"LogSelectorOp", /* NT_LogSelectorOp */
	"MetricQuery", /* NT_MetricQuery */
	"NestedLabelKey", /* NT_NestedLabelKey */
	"Pipeline", /* NT_Pipeline */
	"Pipelines", /* NT_Pipelines */
	"PipelinesMaybe", /* NT_PipelinesMaybe */
	"Query", /* NT_Query */ 
}

var tToString = []string { 
	"!=", /* T_0 */
	"!~", /* T_1 */
	"(", /* T_2 */
	")", /* T_3 */
	",", /* T_4 */
	".", /* T_5 */
	"<", /* T_6 */
	"<=", /* T_7 */
	"=", /* T_8 */
	"=~", /* T_9 */
	">", /* T_10 */
	">=", /* T_11 */
	"[", /* T_12 */
	"]", /* T_13 */
	"by", /* T_14 */
	"count_over_time", /* T_15 */
	"duration", /* T_16 */
	"level", /* T_17 */
	"string", /* T_18 */
	"sum", /* T_19 */
	"var_name", /* T_20 */
	"{", /* T_21 */
	"|", /* T_22 */
	"|=", /* T_23 */
	"|~", /* T_24 */
	"}", /* T_25 */ 
}

var stringNT = map[string]NT{ 
	"LabelFilter":NT_LabelFilter,
	"LabelFilterOp":NT_LabelFilterOp,
	"LabelKey":NT_LabelKey,
	"LineFilter":NT_LineFilter,
	"LineFilterOp":NT_LineFilterOp,
	"LogQuery":NT_LogQuery,
	"LogSelector":NT_LogSelector,
	"LogSelectorMember":NT_LogSelectorMember,
	"LogSelectorMembers":NT_LogSelectorMembers,
	"LogSelectorMembersMaybe":NT_LogSelectorMembersMaybe,
	"LogSelectorOp":NT_LogSelectorOp,
	"MetricQuery":NT_MetricQuery,
	"NestedLabelKey":NT_NestedLabelKey,
	"Pipeline":NT_Pipeline,
	"Pipelines":NT_Pipelines,
	"PipelinesMaybe":NT_PipelinesMaybe,
	"Query":NT_Query,
}
